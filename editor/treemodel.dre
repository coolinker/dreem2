<!--
Copyright 2015 Teem2 LLC. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the License for the specific language governing permissions and limitations under the License.
-->
<class name="editortreeitem" extends="treeitem" with="dropable, droptarget"
  draggroups="{editable:true}"
  allowabort="true" distancebeforedrag="1"
>
  <!--// Life Cycle /////////////////////////////////////////////////////////-->
  <method name="initNode" args="parent, attrs">
    this.super();
    
    // Don't allow dragging of root view
    var targetComponent = this._getTargetComponent();
    if (targetComponent) {
      if (targetComponent === editor.content_bg.content.inner) {
        this.setAttribute('isdraggable', false);
      } else if (targetComponent.isA(dr.AnimBase)) {
        this.isanimation = true;
      }
    }
  </method>


  <!--// Methods ////////////////////////////////////////////////////////////-->
  <!--// Drag and Drop Support //-->
  <method name="startDrag" args="event">
    //this._start();
    this.super();
    
    // Make half opacity during drag
    var target = this.treecontainer;
    this._origY = this.y;
    this._origParent = target;
    var pos = target.getAbsolutePosition(target.root.parent.parent);
    target.setActualAttribute('visible', false);
    this.setAttribute('parent', target.root.parent.parent);
    this.setAttribute('dragoffsety', pos.y);
    this.setAttribute('opacity', 0.5);
    this.setAttribute('clickable', false);
  </method>
  
  <method name="updatePosition" args="x, y">
    if (!this.disabled && this.isdraggable) this.super(0, y);
  </method>
  
  <method name="notifyDrop" args="dropable, isAbort">
    this.super();
    
    // Checking for undefined tells us we're in the over view version of notifyDrop
    if (isAbort === undefined && dropable && dropable.isA(dr.treeitem)) {
      this._stop(this._getTargetComponent(), dropable._getTargetComponent());
    }
  </method>

  <method name="_stop" args="droptarget, target">
    // TODO: remove check for _isInReplicator() when we have a true class editor. For 
    // now, it prevents attempts to reparent child views inside replicated classes. 
    if (target._isInReplicator()) return;
    
    // started dragging, create compound for target with current values
    var E = dr.editor,
      EAU = E.editorattrundoable;
      undoX = new EAU({target:target, attribute:'x', oldvalue:target.getAttribute('x'), newvalue:'0'}),
      undoY = new EAU({target:target, attribute:'y', oldvalue:target.getAttribute('y'), newvalue:'0'}),
      undoP = new E.editorattrundoable({target:target, attribute:'parent', oldvalue:target.parent, newvalue:droptarget}),
      undoO = new E.orderundoable({target:target, oldprevsibling:target.getPrevSiblingView()}),
      compound = new E.compoundundoable();
    
    compound.add(undoX).add(undoY);
    
    // Must be last so that dragging into a parent that already has a layout works as expected. To repro,
    // but a view at x=10, drag it into a view with only an x-spacedlayout, undo the drag and then
    // notice the view did not get put back at 10, but instead at 0.
    compound.add(undoO).add(undoP);
    
    actions.do(compound);
  </method>

  <method name="notifyDropFailed">
    this._abort();
  </method>

  <method name="notifyDropAborted">
    this._abort();
  </method>

  <method name="_abort">
    if (this._origParent.destroyed) {
      this.destroy();
    } else {
      this.setAttribute('y', this._origY);
      this.setAttribute('parent', this._origParent);
      this.moveToBack();
    }
  </method>

  <method name="stopDrag" args="event, isAbort">
    this.super();
    
    // Restore opacity after drag
    if (!this.destroyed) {
      this.treecontainer.setActualAttribute('visible', true);
      this.setAttribute('opacity', 1);
      this.setAttribute('clickable', true);
    }
  </method>

  <method name="notifyDragEnter" args="dropable">
    if (this.isdragging) return;
    
    this.__origBoxShadow = this.getActualAttribute('boxshadow');
    this.setActualAttribute('boxshadow', [0, 0, 6, 1, '#009900']);
  </method>

  <method name="notifyDragLeave" args="dropable">
    if (this.isdragging) return;
    
    this.setActualAttribute('boxshadow', this.__origBoxShadow);
  </method>

  <method name="willAcceptDrop" args="dropable">
    if (this.isdragging) return false;
    
    // Tree on tree case
    if (dropable === this || (dropable._origParent && dropable._origParent.parent === this.treecontainer)) return false;
    
    var targetComponent = this._getTargetComponent();
    if (!targetComponent) return false;
    
    // Determine Leaf Combinations
    if (targetComponent.isA(dr.View)) {
      if (!dropable.isbehavior && !dropable.isanimation && targetComponent.isLeaf(dropable)) return false;
    } else if (targetComponent.isA(dr.Animator)) {
      // Animators are always leaves
      return false;
    } else if (targetComponent.isA(dr.AnimGroup)) {
      // Only Animators and AnimGroups can be dropped on AnimGroups
      if (!dropable.isanimation) return false;
    } else {
      // Don't allow dropping on unexpected tree items.
      return false;
    }
    
    // No dropping on descendants of self or our parent
    if (dropable.target && (targetComponent.isDescendantOf(dropable.target) || dropable.target.parent === targetComponent)) return false;
    
    return this.super();
  </method>

  <method name="_getTargetComponent">
    var data = this.treecontainer.data;
    if (!data) return null;
    if (!Array.isArray(data)) return data.ref;
  </method>
</class>

<class name="editortree" extends="tree">
  <!--// Methods ////////////////////////////////////////////////////////////-->
  <method name="getReplicatorClassname">
    return 'editortree';
  </method>
  <method name="getTreeItemClassname">
    return 'editortreeitem';
  </method>
</class>

<editortree id="treemodel" multipleselection="false"
  selectcolor="${config.selection_color}"
  disabled="${!editor.editmode}"
>
  <handler name="updateSelection" event="onselected" args="view" reference="selectionmanager">
    if (view) {
      // Map inner view to root since the inner view is what allows editing of
      // the root view for the screen.
      if (view === editor.content_bg.content.inner) view = view.getRoot();
      
      // Select in tree
      var viewId = view.id;
      if (viewId) {
        if ((function walk(v) {
          if (v.data && v.data.id === viewId) {
            if (!v.selected) v.triggerSelection(true);
            return true;
          }
          var svs = v.subviews, i = svs.length;
          while (i) {
            if (walk(svs[--i])) return true;
          }
          return false;
        })(this)) return;
      }
    }
    
    this.clearSelection();
  </handler>

  <method name="selectHandler" args="sel, d">
    var viewid = d.id;
    if (viewid) {
      if (sel) {
        var view = this._getEditable(viewid);
        if (view !== selectionmanager.selected) selectionmanager.select(view);
      } else {
        selectionmanager.select(null);
      }
    }
  </method>

  <method name="_getEditable" args="id">
    return dr.sprite.retrieveGlobal(id);
  </method>

  <handler event="onmodelchange" reference="editormodel">
    // Reload tree
    var d = editormodel.model;
    if (d) {
      var model = [],
        tagsWithIcons = {text:true, bitmap:true, replicator:true, dataset:true, animator:true, animgroup:true},
        screenname = editormodel.screenname,
        self = this;
      
      (function parser(m, o) {
        // If we're at the root node, parse down until we find the screen with 
        // a matching name
        if (o.tag === '$root') {
          for (var i=0; o.child.length > i; i++) {
            var composition = o.child[i];
            if (composition.tag == 'composition') {
              for (var j=0; composition.child.length > j; j++) {
                var screens = composition.child[j];
                if (screens.tag == 'screens') {
                  o = screens.child;
                  for (var h=0; o.length > h; h++) {
                    var screen = o[h];
                    if (screen.tag == 'screen' && screen.attr && screen.attr.name == screenname) {
                      o = screen.child;
                      break;
                    }
                  }
                  break;
                }
              }
              break;
            }
          }
        }
        
        // for each child, build a normalized representation of the object 
        // that looks like {title:'foo', image:imageid, id:'editor_id', items:[child,ren]}
        var name, id, scr, tag, attr, object, s = 0, len = o.length;
        for (; len > s;) {
          scr = o[s++];
          tag = scr.tag;
          if (tag && tag[0] !== '$') {
            attr = scr.attr;
            id = attr ? attr.id : '';
            
            // Keep all child nodes that are not layouts, behaviors or animators.
            if (id) {
              var view = self._getEditable(id);
              
              if (view && !view.isA(dr.Layout) && !view.isA(dr.behavior.behavior)) {
                if (attr.title) {
                  name = attr.title
                } else if (attr.name) {
                  name = attr.name;
                } else if (attr.event) {
                  name = attr.event;
                } else if (attr.text) {
                  name = '"' + attr.text + '"';
                } else {
                  name = tag.charAt(0).toUpperCase() + tag.slice(1);
                }
                
                var nameLen = name.length;
                if (nameLen > 35) name = name.substring(0, 16) + '...' + name.substring(nameLen - 16, nameLen);
                
                object = {
                  title:name, 
                  image:config.img_root + (tagsWithIcons[tag] ? tag : 'view') + '.png', 
                  id:id,
                  ref:view.isRoot() ? editor.content_bg.content.inner : view
                };
                
                if (scr.child) {
                  var items = [];
                  parser(items, scr.child);
                  if (items.length) object.items = items;
                }
                
                m.push(object);
              }
            }
          }
        }
      })(model, d);
      
      this.setAttribute('data', model);
      
      // Update the selection after model changes since the selection will
      // get cleared.
      var selected = selectionmanager.selected;
      if (selected) this.updateSelection(selected);
    }
  </handler>
</editortree>
