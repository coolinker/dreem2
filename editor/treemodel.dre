<!--
Copyright 2015 Teem2 LLC. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the License for the specific language governing permissions and limitations under the License.
-->
<class name="editortreeitem" extends="treeitem" with="dropable, droptarget"
  draggroups="{editable:true}"
  allowabort="true" distancebeforedrag="1"
>
  <!--// Life Cycle /////////////////////////////////////////////////////////-->
  <method name="initNode" args="parent, attrs">
    this.super();
    
    // Don't allow dragging of root view
    var targetComponent = this._getTargetComponent();
    if (targetComponent) {
      if (targetComponent === editor.content_bg.content.inner) {
        this.setAttribute('isdraggable', false);
      } else if (targetComponent.isA(dr.AnimBase)) {
        this.isanimation = true;
      }
    }
  </method>


  <!--// Methods ////////////////////////////////////////////////////////////-->
  <!--// Drag Support //-->
  <method name="startDrag" args="event">
    //this._start();
    this.super();
    
    // Make half opacity during drag
    var target = this.treecontainer;
    this._origY = this.y;
    this._origParent = target;
    var pos = target.getAbsolutePosition(target.root.parent.parent);
    target.setActualAttribute('visible', false);
    this.setAttribute('parent', target.root.parent.parent);
    this.setAttribute('dragoffsety', pos.y);
    this.setAttribute('opacity', 0.5);
    this.setAttribute('clickable', false);
  </method>
  
  <method name="updatePosition" args="x, y">
    if (!this.disabled && this.isdraggable) this.super(0, y);
  </method>

  <method name="notifyDropFailed">
    this._abort();
  </method>

  <method name="notifyDropAborted">
    this._abort();
  </method>

  <method name="_abort">
    this.setAttribute('y', this._origY);
    this.setAttribute('parent', this._origParent);
    this.moveToBack();
  </method>

  <method name="stopDrag" args="event, isAbort">
    this.super();
    
    // Restore opacity after drag
    this.treecontainer.setActualAttribute('visible', true);
    this.setAttribute('opacity', 1);
    this.setAttribute('clickable', true);
  </method>

  <!--// Drop Support //-->
  <method name="notifyDragEnter" args="dropable">
    if (this.isdragging) return;
    
    this.__origBoxShadow = this.getActualAttribute('boxshadow');
    this.setActualAttribute('boxshadow', [0, 0, 6, 1, '#009900']);
  </method>

  <method name="notifyDragLeave" args="dropable">
    if (this.isdragging) return;
    
    this.setActualAttribute('boxshadow', this.__origBoxShadow);
  </method>

  <method name="willAcceptDrop" args="dropable">
    if (this.isdragging) return false;
    
    // Tree on tree case
    if (dropable === this || (dropable._origParent && dropable._origParent.parent === this.treecontainer)) return false;
    
    var targetComponent = this._getTargetComponent();
    if (!targetComponent) return false;
    
    // Determine Leaf Combinations
    if (targetComponent.isA(dr.View)) {
      if (!dropable.isbehavior && !dropable.isanimation && targetComponent.isLeaf(dropable)) return false;
    } else if (targetComponent.isA(dr.Animator)) {
      // Animators are always leaves
      return false;
    } else if (targetComponent.isA(dr.AnimGroup)) {
      // Only Animators and AnimGroups can be dropped on AnimGroups
      if (!dropable.isanimation) return false;
    } else {
      // Don't allow dropping on unexpected tree items.
      return false;
    }
    
    // No dropping on descendants of self or our parent
    if (dropable.target && (targetComponent.isDescendantOf(dropable.target) || dropable.target.parent === targetComponent)) return false;
    
    return this.super();
  </method>

  <method name="_getTargetComponent">
    var data = this.treecontainer.data;
    if (!Array.isArray(data)) return data.ref;
  </method>
</class>

<class name="editortree" extends="tree">
  <!--// Methods ////////////////////////////////////////////////////////////-->
  <method name="getReplicatorClassname">
    return 'editortree';
  </method>
  <method name="getTreeItemClassname">
    return 'editortreeitem';
  </method>
</class>

<editortree id="treemodel" multipleselection="false"
  selectcolor="${config.selection_color}"
  disabled="${!editor.editmode}"
>
  <handler name="updateSelection" event="onselected" args="view" reference="selectionmanager">
    if (view) {
      // Map inner view to root since the inner view is what allows editing of
      // the root view for the screen.
      if (view === editor.content_bg.content.inner) view = view.getRoot();
      
      // Select in tree
      var viewId = view.id;
      if (viewId) {
        if ((function walk(v) {
          if (v.data && v.data.id === viewId) {
            if (!v.selected) v.triggerSelection(true);
            return true;
          }
          var svs = v.subviews, i = svs.length;
          while (i) {
            if (walk(svs[--i])) return true;
          }
          return false;
        })(this)) return;
      }
    }
    
    this.clearSelection();
  </handler>

  <method name="selectHandler" args="sel, d">
    var viewid = d.id;
    if (viewid) {
      if (sel) {
        var view = this._getEditable(viewid);
        if (view !== selectionmanager.selected) selectionmanager.select(view);
      } else {
        selectionmanager.select(null);
      }
    }
  </method>

  <method name="_getEditable" args="id">
    return dr.sprite.retrieveGlobal(id);
  </method>

  <handler event="onmodelchange" reference="editormodel">
    // Reload tree
    var d = editormodel.model;
    if (d) {
      var model = [],
        screenname = editormodel.screenname,
        self = this;
      
      (function parser(m, o) {
        // if we're at the root node, so parse down through until we find the
        // screen with a matching name
        if (o.tag == '$root') {
          for (var i=0; o.child.length > i; i++) {
            var composition = o.child[i];
            if (composition.tag == 'composition') {
              for (var j=0; composition.child.length > j; j++) {
                var screens = composition.child[j];
                if (screens.tag == 'screens') {
                  o = screens.child;
                  for (var h=0; o.length > h; h++) {
                    var screen = o[h];
                    if (screen.tag == 'screen' && screen.attr && screen.attr.name == screenname) {
                      o = screen.child;
                      break;
                    }
                  }
                  break;
                }
              }
              break;
            }
          }
        }
        
        // for each child, build a normalized representation of the object 
        // that looks like { title:'foo', image:imageid, id:'editor_id', items:[child,ren]}
        var title, name, id, scr, tag, attr, img, object, s = 0, len = o.length;
        for (; len > s;) {
          scr = o[s++];
          tag = scr.tag;
          if (tag && tag[0] != '$') {
            title = name = id = '';
            attr = scr.attr;
            img = config.img_root;
            if (["text", "bitmap", "replicator", "dataset", "animator", "animgroup"].indexOf(tag) >= 0) {
              img += tag + '.png';
            } else {
              img += 'view.png';
            }
            
            if (attr) {
              id = attr.id;
              
              if (attr.title) {
                name = attr.title
              } else if (attr.name) {
                name = attr.name;
              } else if (attr.event) {
                name = attr.event;
              } else if (attr.text) {
                name = '"' + attr.text + '"';
              }
            }
            
            title = name ? name : tag.charAt(0).toUpperCase() + tag.slice(1);
            
            object = {title:title, image:img};
            if (id) object.id = id;
            if (scr.child) {
              var items = [];
              parser(items, scr.child);
              if (items.length) object.items = items;
            }
            
            // Keep all child nodes that are not layouts, behaviors or animators.
            if (id) {
              var view = self._getEditable(id);
              if (view && !view.isA(dr.Layout) && !view.isA(dr.behavior.behavior)) {
                m.push(object);
                
                object.ref = view.isRoot() ? editor.content_bg.content.inner : view;
              }
            }
          }
        }
      })(model, d);
      
      this.setAttribute('data', model);
      
      // Update the selection after model changes since the selection will
      // get cleared.
      var selected = selectionmanager.selected;
      if (selected) this.updateSelection(selected);
    }
  </handler>
</editortree>
