<tree id="treemodel"
  x="${this.depth * 10}" multipleselection="false" indentwidth="20"
  data="${this.normalizedmodel.data}"
>
  <handler event="onselected" args="view" reference="selectionmanager">
    if (view) {
      // Map inner view to root since the inner view is what allows editing of
      // the root view for the screen.
      if (view === editor.content_bg.content.inner) view = view.getRoot();
      
      this._selectInTree(this._getViewForId(view.id))
    } else {
      this.clearSelection();
    }
  </handler>

  <method name="_selectInTree" args="view">
    if (view) {
      var walk = function(v) {
        if (!v.selected && v.data && v.data.id == view.id) {
          v.triggerSelection(true)
          return true;
        }
        for (var i = 0; v.subviews.length > i; i++) {
          if (walk(v.subviews[i])) return true;
        }
        return false;
      };
      
      return walk(this);
    }
  </method>

  <method name="_getViewForId" args="viewid">
    return window[viewid];
  </method>

  <method name="selectHandler" args="sel, d">
    var viewid = d.id;
    if (viewid) {
      if (sel) {
        var view = this._getViewForId(viewid);
        if (view !== selectionmanager.selected) selectionmanager.select(view);
      } else {
        selectionmanager.select(null);
      }
    }
  </method>

  <dataset name="normalizedmodel" data="${editormodel.model}">
    <setter name="data" args="d">
      var model = [];

      var parser = function(m, o) {
        //if we're at the root node, so parse down through until we find the first screen
        if (o.tag == '$root') {
          for (var i =0; i < o.child.length; i++) {
            var composition = o.child[i];
            if (composition.tag == 'composition') {
              for (var j=0;j < composition.child.length;j++) {
                var screens = composition.child[j];
                if (screens.tag == 'screens') {
                  o = screens.child;
                  for (var h=0; h < o.length; h++) {
                    var screen = o[h];
                    if (screen.tag == 'screen' && screen.attr && screen.attr.name == 'default') {
                      o = screen.child;
                      break;
                    }
                  }
                  break;
                }
              }
              break;
            }
          }
        }

        //for each child, build a normalized representation of the object that looks like { title:'foo', image:imageid, id:'editor_id', items:[child,ren]}
        for (var s =0; s < o.length; s++) {
          var scr = o[s];
          if (scr.tag && scr.tag[0] != '$') {
            var title = '';
            var name = '';
            var tag = scr.tag;
            var id = '';
            if (scr.attr) {
              var attr = scr.attr;

              id = attr.id;

              if (attr.title) {
                name = attr.title
              } else if (attr.name) {
                name = attr.name;
              } else if (attr.event) {
                name = attr.event;
              }
            }

            if (name) {
              title = tag + ' {"' + name + '"}';
            } else {
              title = tag;
            }

            var items = [];
            var object = { title: title };
            if (id) {
              object['id'] = id;
            }
            if (scr.child) {
              parser(items, scr.child);
              if (items.length) {
                object['items'] = items;
              }
            }
            if (object.id) {
              var obj = window[object.id];
              if (obj && obj.isA(dr.View)) {
                m.push(object);
              }
            }
          }
        }
      };
      if (d) {
        parser(model, d);
      }
      this.super(model);
    </setter>
  </dataset>
</tree>
